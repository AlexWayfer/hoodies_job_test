# Тестовое задание для вакансии Ruby developer в Hoodies

## Постановка

В файле `Task.rb` находится программа, выполняющая обработку данных из файла.
Тест показывает как программа должна работать.
В этой программе нужно обработать файл данных `data_large.txt`.

Ожидания от результата:

* корректная обработатка файла data_large.txt;
* проведена оптимизация кода и представлены ее результаты;
* production-ready код;
* применены лучшие практики.

Отчёт в JSON:

- Сколько всего юзеров
- Сколько всего уникальных браузеров
- Сколько всего сессий
- Перечислить уникальные браузеры в алфавитном порядке через запятую и капсом
- По каждому пользователю
  - сколько всего сессий
  - сколько всего времени
  - самая длинная сессия
  - браузеры через запятую
  - Хоть раз использовал IE?
  - Всегда использовал только Хром?
  - даты сессий в порядке убывания через запятую

По возможности использовать [`dry-rb`](https://dry-rb.org/).

## Решение

### Разархивация файла

Неясно, ожидается, что распаковка архива будет происходить в скрипте (всегда приходит архив),
или можно разархивировать вручную перед выполнением. Сделал в скрипте, несложно.

### Чтение файла

Хоть у меня в системе обычный `#read` исполняется быстро, наверняка ожидается
постепенное чтение файла, чтобы не перегружать ОЗУ.

Формат данных слишком уж похож на CSV, но `CSV.foreach` не принимает IO-like инстанцию
`Zlib::GzipReader`, так что парсинг каждой линии.

---

Фигню написал, не вникнув в цепочку вызовов. Читается сжатый файл целиком,
преобразуется в `StringIO`, а далее распаковывается полинейно, как я понял,
что значительно быстрее всё равно, чем распаковать весь и идти полинейно.

Наверное, можно попробовать оптимизировать и чтение архива,
[вроде такого](https://stackoverflow.com/a/22845590/2630849), но я не хочу.

### Запись файла

Непонятно, исходные данные всегда отсортированы или нет (на первый взгляд — да, но вдруг нет),
и могу ли я писать результат так же последовательно (через append mode)
или необходимо держать всё в ОЗУ, так что остановился на последнем.

---

Append не получится из-за динамичных "total" данных.

### `dry-rb`

Тут хватило бы `dry-struct`, но можно притянуть и `dry-monads` для последовательных операций,
и `dry-validation` для валидации входящих данных, и туда же `dry-types` — непонятно,
на чём лучше остановиться. Сделал максимум, пожалуй (`dry-system` не очень понимаю и не очень хочу,
особенно для проекта из одной задачи).

С задержкой осознал, что все `Struct` и `Schema` инициализируются из `Hash` данных,
а у нас CSV без ключей. Либо не использовать их, либо вручную добавлять ключи перед инициализацией.
Первое, наверное, производительнее, но для работы с Dry использую второе.

Хотел прикрутить compositing schemas, но с ручным добавлением ключей сложно и бесполезно.
Кстати, они экспериментальны до версии 2.0.

От валидаторов отказался, потому что не нашёл им адекватного применения в данной задаче.

Решил инициализировать структуры решил мета-программированием для уменьшения повторений.
Требует только строгого порядка в `Struct`, о чём написал комментарий. Но не вижу недостатка в этом:
строгий порядок потребуется либо там, либо в условной константе с ключами (повторяющими аттрибуты).

Использовал кастомный тип `UpcasedString` для браузера в сессии: не вижу,
когда понадобятся raw данные, а преобразование Dry-методом может быть лаконичнее в данном стеке.

Не понравилось:

*   `Types::Strict::String` требует тип `String`, `Types::Coercible::String` пробует
    конвертировать в `String`, а `Types::String` что делает? Приходит `Integer` — оставляет его?
    Зачем…
    *   Есть метод `.optional`, почему это метод, а не namespace, как с `Coercible` или `Strict`?
        Не однообразно. И что будет при `Types::Strict::String.optional`? Либо строка, либо `nil`,
        либо ошибка? А в других случаях либо попытка конвертации, либо оставляет данные как есть?
        А для `Types::Coercible::String.optional` он попробует конвертировать `nil` в `''`?
    *   Ключ вида `:gteq` для `.constrained` плохо читается и выбивается из Ruby naming.
        Операторы нравятся больше, пример — Sequel.
        Либо блоки, либо `:>= => 18` и `'>=': 18` — валидные формы.
    *   А зачем вообще `Strict`?… Я просто делал подобные вещи
        в [Formalism](https://github.com/AlexWayfer/formalism), и там коерсия почти всегда,
        и в реальных коммерческих проектах всё устраивало, а остальное — дело валидации.
        Зачем исключение, если пришло не `18`, а `'18'`? Избежать данных вида `'#<Object:...'`?
        Не сталкивался, обычно наоборот строка приходит, которую нужно в объект конвертировать,
        и/или коерсия может произойти до входа данных, но ладно.

*   Вот есть в задаче поле `age` у пользователя. Оно не используется нигде.
    Мне его требовать, валидировать, что делать?

*   `time` лучше называть `duration`, а то неоднозначно смотрится рядом с `date`,
    да и вообще вряд ли корректно. Оставил, чтобы не было путаницы с ключами в ожидаемом JSON.

*   Почему нет `Types::Coercible::Date`? Есть `Types::JSON::Date`, но у нас скорее приходит CSV,
    и дата там может быть в любом формате, так что пришлось писать кастомный тип.

*   Очень тонкие грани и не очень хорошая документация про `value`, `filled`, `maybe` и `optional`
    в `dry-schema` и вытекающем `dry-validation`.

*   Зачем `constrained` у `Struct`, когда есть куча возможностей у `dry-schema` и `dry-validation`?
    Кажется, что-то где-то лишнее…

*   Для `Types.enum` обязан использовать `.default.enum` и не могу `.enum.default`,
    что менее читаемо, менее интуитивно (не зря об этом пометка в документации), костыльно.

### Оптимизации

*   Чтение и запись файлов упомянуты выше.

*   В `Task.rb` используется `Array#count`, хотя `Array#size` производительнее (и не принимает блок).

*   Можно было бы попробовать применить [`Enumerator#to_json`](https://collectiveidea.com/blog/archives/2015/03/13/optimizing-rails-for-memory-usage-part-4-lazy-json-generation-and-final-thoughts), но я сомневаюсь, что мы получим `SystemStackError` на данных такого типа, плюс нам придётся держать исходный массив в ОЗУ, но можно конвертировать данные сразу в JSON-строки при желании.

*   Для уникальных браузеров взял `Set`, вроде достаточно и быстрее.

    *   Попутно исправил потенциальную проблему с тем, что браузеры в разном регистре
        не считались уникальными при подсчёте их количества.

    *   Даже лучше `SortedSet`, хотя его вынесли в отдельный gem с Ruby 3.

*   Не стал хранить общий набор сессий, а сразу присваиваю нужному пользователю.
    Требует наличия данных пользователя перед данными его сессий в исходных данных.
    Условий по этому порядку не вижу, но кажется логичным и вряд ли в реальном мире будет не так.

    *   Хотел добавить кастомных полей к `User` struct, потом нашёл [такой комментарий](https://github.com/dry-rb/dry-types/issues/106#issuecomment-230178002)
        и решил, что выделю под это отдельный класс `UserStat`.
        В Dry экосистеме не нашёл подходящего, так что нативный.
        В том числе позволило быть менее зависимым от порядка данных
        (если вдруг сессии для пользователя пришли раньше раньше данных самого пользователя).

    *   Очень странным и не очень правильным кажется Hash с ключами в виде имён пользователей,
        не стал тут оптимизировать и как-то заранее его инициализировать и параллельно заполнять.

*   Скрипт на итоговых данных выполняется долго. `rbspy`, увы, не дал мне внятной информации
    из-за `(unknown) [c function] - (unknown)`. [По схожей причине](https://github.com/rbspy/rbspy/issues/110#issuecomment-421076539)
    я почти не использовал его в коммерческих проектах, да и там был затык обычно очевидный в SQL
    или подобном.

    *   Но я долждался полного прогона, и на [Flamegraph](flamegraphs/1.svg) выявил,
        что большую долю занимает `CSV.parse_line` (хотел поканоничнее),
        заменил на `line.split ','`.

    *   [Следующий прогон](flamegraphs/2.svg) смутил `parse [c function] - (unknown)`,
        что, как я понял, относится к `Date.parse`.
        Заменил `.contructor(Date)` тип на `String.constrained(format:)` с регулярным выражением,
        которое, увы, пропустит ошибки с числами в феврале. Не знаю, что важнее: корректная дата
        (может ли прийти некорректная) или производительность. Оставил производительный вариант.
        Мог бы (наверное, не пробовал) использовать встроенный `Types::JSON::Date`, но не стал
        по вышеописанным причинам (читаем не из JSON).

    *   [Третий прогон](flamegraphs/3.svg) показал не очень производительные `zip`
        и `dry-inflector`, и хоть мне не нравится явное перечисление и повторение переменной,
        но ладно — оптимизировал.

    *   [Четвёртый прогон](flamegraphs/4.svg) уже в основном отображает внутренности Dry стэка.
        Полагаю, с нативными классами было бы ещё производительнее, но т.к. в постановке задачи
        фигурировало "желательно с Dry" — оставляю.

*   Памяти кушается тоже несколько ГБ, и вот тут может пригодиться оптимизация через генерацию
    JSON-строк, но она будет валидна только при условии, что все входящие данные
    строго отсортированы, а такого условия в постановке задачи я не увидел.

    Работа без Dry стэка, в частности монад и структур, наверное тоже будет потреблять меньше ОЗУ.

*   Можно было бы использовать многопоточность, учитывая независимую от порядка текущую
    структуру данных, но IO-операций почти нет, а адаптировать к Ruby 3 или JRuby довольно
    экспериментально и лениво.

Для бенчмарков есть [простой скрипт](https://gist.github.com/AlexWayfer/37ebb8b9f3429650b86fb4cea7ae3693).

Не понравилось:

*   "Проведена оптимизация кода", "Production-ready code", "Применены лучшие практики" —
    очень размытые понятия. Оптимизация кода для чего? Есть, например, классический конфликт
    CPU vs. RAM. Есть оптимизации для разных объёмов данных.
    Для какого именно production готовность? У всех разный production,
    в том числе по стабильности и качеству.
    "Лучшие практики" на чей взгляд? Для чего? Не бывает серебряных пуль, всё зависит от задачи.

*   Из-за того, что браузеры у пользователя не уникальны (ошибка постановки задачи?), пришлось
    вместо `SortedSet` в данном случае использовать `Array`.

### Тесты

Наверное, тесты для `Struct` избыточны.

Стоит покрыть тестами все монады, но я ограничился "конечным" из задачи.
